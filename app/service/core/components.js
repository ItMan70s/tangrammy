function Duration() {	this.format = "YYYY/MM/DD hh:mm";	this.endDate = false;}Duration.prototype.show = function(val0, val1, tz) {	var date1 = (val0 instanceof Date)? val0 : new Date(val0);	var date2 = (val1 instanceof Date)? val1 : new Date(val1);	var d1 = date1.array(tz);	var d2 = date2.array(tz);		var htm = d1[1] + "/" + d1[2] + " " + d1[3] + ":" + d1[4] + " ~ ";	if (d2[1] == d1[1] && d2[2] == d1[2]) {		htm += d2[3] + ":" + d2[4];	} else {		htm += d2[1] + "/" + d1[2] + " " + d2[3] + ":" + d2[4];	}	return htm;}function validateComp(cType, org, val) {	if (!org || !val) {		return "";	}	var rserv = new Reservation();	return rserv.validate(org, val.mid(0, "+"), val.mid("+", ":"));}/*Returns milliseconds since midnight, January 1, 1970 in the GMT timezone.Get/Set value to keyUsage: datevar.val(key[, value])*/Date.prototype.val = function(key, value) {	var v = "";	if (key.length != 2) {		key = key.toLowerCase();	}	switch(key) {	case "yyyy":	case "YY":	case "year":		if (arguments.length > 1) {			this.setUTCFullYear(value);		} else {			v = this.getUTCFullYear();		}		break;	case "MM":	case "month":		if (arguments.length > 1) {			this.setUTCMonth(value - 1);		} else {			v = this.getUTCMonth() + 1;		}		break;	case "DD":	case "date":	case "days":		if (arguments.length > 1) {			this.setUTCDate(value);		} else {			v = this.getUTCDate();		}		break;	case "hh":	case "hours":		if (arguments.length > 1) {			this.setUTCHours(value);		} else {			v = this.getUTCHours();		}		break;	case "mm":	case "minutes":		if (arguments.length > 1) {			this.setUTCMinutes(value);		} else {			v = this.getUTCMinutes();		}		break;	case "ss":	case "seconds":		if (arguments.length > 1) {			this.setUTCSeconds(value);		} else {			v = this.getUTCSeconds();		}		break;	case "ms":		if (arguments.length > 1) {			this.setUTCMilliseconds(value);		} else {			v = this.getUTCMilliseconds();		}		break;	}	v += "";	if (key.length < v.length) {		v = v.substring(0, key.length);	} else if (key.length > v.length) {		v = v.pad(key.length);	} 	return v;};/*Returns date in array(year, month, date, hours, minutes, seconds, milliseconds) in specified timezone offset.Usage: datevar.val(timezoneoffset)Parameters:datevar Must. The date var to transform.timezoneoffsetOptional. The timezone offset could be hour(s)/minute(s)/millisecond(s). 0 if not specified. */Date.prototype.array = function(tz) {	if (arguments.length > 0) {		if (tz > -20.0 && tz < 20.0) {			tz *= 3600000;		} else if (tz > -1000 && tz < 1000) {			tz *= 60000;		}	} else {		tz = 0;	}		var d = (tz != 0) ? new Date(this + tz) : this;	return new Array(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());}/*Returns milliseconds since midnight, January 1, 1970 in the GMT timezone.Usage: datevar.now()*/Date.prototype.now = function() {	return this - 0;};// (new Date()).Format("yyyy-MM-dd hh:mm:ss.S") ==> 2006-07-02 08:09:04.423 // (new Date()).Format("yyyy-M-d h:m:s.S")      ==> 2006-7-2 8:9:4.18 Date.prototype.format = function (fmt) {    var o = {        "M+": this.getMonth() + 1,         "D+": this.getDate(),        "d+": this.getDate(),        "H+": this.getHours(),        "h+": this.getHours(),        "m+": this.getMinutes(),        "s+": this.getSeconds(),        "q+": Math.floor((this.getMonth() + 3) / 3),        "S": this.getMilliseconds()    };    if (/(y+)/i.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length));    for (var k in o)    if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length)));	if (fmt.contains("Z")) {		var tz = -1 * this.getTimezoneOffset();		if (tz % 60 == 0) {			fmt = fmt.replace("Z", "(UTC " + (tz / 60) + ":00)");		} else {			fmt = fmt.replace("Z", "(UTC " + Math.floor(tz / 60) + ":30)");		}	}    return fmt;}Date.prototype.convert = function(val, tz, fmt) {	if (!val) {		return "";	}	if (!val.contains("UTC")) {		val = val.substring(0, val.lastIndexOf(" "));	}	var otz = "";	if (val.contains("UTC")) {		otz = val.mid("UTC ", ")");		otz = eval("" + val.mid("UTC ", ":") + " * 60 + " + val.mid(val.lastIndexOf(":") + 1, ")") ); 	}	if (otz != tz) {		tz = (tz - otz) * 60000;	}	return new Date(Date.parse(val) + tz).format(fmt);}Date.prototype.showDuration = function(val0, val1, tz) {	if (tz) {		if (tz > -20.0 && tz < 20.0) {			tz *= 3600000;		} else if (tz > -1000 && tz < 1000) {			tz *= 60000;		}	} else {		tz = 0;	}	var d1 = (val0 instanceof Date)? val0 : new Date(val0 + tz);	var d2 = (val1 instanceof Date)? val1 : new Date(val1 + tz);	var htm = d1.format("MM/dd hh:mm");	var val = d2.format("MM/dd hh:mm");	if (htm.substr(0, 5) == val.substr(0, 5)) {		htm += "~" + val.substr(6);	} else {		htm += "~" + val;	}	return htm;};Date.prototype.daysOfMonth = function(month, year) {	switch (month) {		case 1:		case 3:		case 5:		case 7:		case 8:		case 10:		case 12:			return 31;		break;		case 4:		case 6:		case 9:		case 11:			return 30;		break;		case 2:			var dat = new Date(year + "/03/01");			dat.setDate(-1);			return (dat.getDate() + 1);		break;	}	return -1}Date.prototype.recent = function(tz) {	var latest = new Array();	if (tz == undefined) {		tz = this.getTimezoneOffset();	}	var d = this.now() + tz * 60000;	var y = new Date(d);	var days = [3, 5, 7, 10, 30, 90];	var x = y.getDate();	var day = "";	for (var i = 0; i < days.length; i++) {		y = new Date(d);		y.setDate(x - days[i]);		day = y.format("yyyy.MM.dd");		y = new Date(d);		y.setDate(x + days[i] + 1);		day += "~" + y.format("yyyy.MM.dd");		latest.push(day + "@Recent " + days[i] + " Days");	}	return latest;}Date.prototype.last = function(num, unit, tz) {	return this.latest(1, num, unit, tz);}Date.prototype.next = function(num, unit, tz) {	return this.latest(-1, num, unit, tz);}Date.prototype.latest = function(or, num, unit, tz) {	unit = (unit + "").toLowerCase();	var latest = new Array();	//var range = "%1 00:00:00.0~%2 23.59.59.999@%3";	var range = "%1@%2";	if (tz == undefined) {		tz = this.getTimezoneOffset();	}	switch (unit) {		case "year":		case "years":			var y = new Date(this.now() + tz * 60000).getFullYear();			var year = "";			for (var i = 0; i < num; i++) {				year = y - i * or;				latest.push(year)				//latest.push(range.arg(year + "/01/01", year + "/12/31", year));			}		break;		case "month":		case "months":			var y = new Date(this.now() + tz * 60000).getFullYear();			var m = new Date(this.now() + tz * 60000).getMonth() + 1;			var month = "";			for (var i = 0; i < num; i++) {				if (m == 0) {					m = 12;					y--;				}				if (m == 13) {					m = 1;					y++;				}				month = y + "." + (m > 9 ? m : "0" + m);				latest.push(month)				//latest.push(range.arg(month + "/01", month + "/" + this.daysOfMonth(m, y), month));				m -= 1 * or;			}		break;		case "day":		case "days":			var y = new Date(this.now() + tz * 60000);			var x = y.getDate();			var day = "";			for (var i = 0; i < num; i++) {				y.setDate(x - i * or);				day = y.format("yyyy.MM.dd");				if (i == 0) {					latest.push(range.arg(day, "Today"));					//latest.push(range.arg(day, day, "Today"));				} else if (i * or == 1) {					latest.push(range.arg(day, "Yesterday"));					//latest.push(range.arg(day, day, "Yesterday"));				} else if (i * or == -1) {					latest.push(range.arg(day, "Tomorrow"));					//latest.push(range.arg(day, day, "Tomorrow"));				} else {					latest.push(day);					//latest.push(range.arg(day, day, day));				}			}		break;		case "week":		case "weeks":			// Sunday~Saturday			var y = new Date(this.now() + tz * 60000);			if (or == 1) {				if (y.getDay() < 6) {					y.setDate(y.getDate() + 6 - y.getDay());				}			} else {				if (y.getDay() > 0) {					y.setDate(y.getDate() - y.getDay());				}			}			var x = y.getDate();			for (var i = 0; i < num; i++) {				var day = "";				for (var k = 0; k < 7; k++) {					day += ", " + y.format("yyyy.MM.dd");										y.setDate(y.getDate() - or);					// next until Sunday, previous until Saturday					if ((or == -1 && y.getDay() == 0) || (or == 1 && y.getDay() == 6) ) {						break;					}				}				day = day.substr(2);				if (i * or == 0) {					latest.push(day + "@This Week");				} else if (i * or == 1) {					latest.push(day + "@Last Week");				} else if (i * or == 1) {					latest.push(day + "@Next Week");				} else {					latest.push(day + "@" + i + ( or == 1 ? " Weeks ago" : " Weeks later"));				}			}			/*				var now = this.now();			var sarting = now - (now + 259200000) % 604800000 + tz * 60000;			var ending = sarting + 604800000 - 1;			// 1970.1.1 is Thursday. 			// 259200000 = 3 * 24 * 3600 * 1000			// 604800000 = 7*24*3600*1000			// 86400000 = 24*3600*1000			range = "%1~%2@%3";			latest.push(range.arg(new Date(sarting).format("yyyy.MM.dd"), new Date(ending).format("yyyy.MM.dd"), "This Week"));			for (var i = 1; i < num; i++) {				sarting -= 604800000 * or;				ending -= 604800000 * or;				for (var d1 = sarting; d1 != ending; d1 += 86400000 * or) {				}				if (i * or == 1) {					latest.push(range.arg(new Date(sarting).format("yyyy.MM.dd"), new Date(ending).format("yyyy.MM.dd"), "Last Week"));				} else if (i * or == -1) {					latest.push(range.arg(new Date(sarting).format("yyyy.MM.dd"), new Date(ending).format("yyyy.MM.dd"), "Next Week"));				} else {					latest.push(range.arg(new Date(sarting).format("yyyy.MM.dd"), new Date(ending).format("yyyy.MM.dd"), i + ( or == 1 ? " Weeks ago" : " Weeks later")));				}			}			*/		break;	}	return latest;}var txt2arrayError = false;function text2array(txt, comma, quote, line, trim) {	if (comma == "\t" || comma == "," || comma == " ") {		return txt2array(txt, comma, quote, line, trim);	}	if (!txt.contains("\t")) {		return txt2array(txt, ",", quote, line, trim);	}	if (!txt.contains(",")) {		return txt2array(txt, "\t", quote, line, trim);	}		var array0 = txt2array(txt, "\t", quote, line, trim);	if (txt2arrayError) {		return txt2array(txt, ",", quote, line, trim);	}		var array1 = txt2array(txt, ",", quote, line, trim);	if (txt2arrayError) {		return array0;	}		var rtn0 = len0 = len1 = num0 = num1 =0;	var avg;		if (array0.length > array1.length) {		rtn0++;	} else {		rtn0--;	}	for (var i = 0; i < array0.length; i++) {		len0 += array0[i].length;		avg = len0 / (i + 1)		num0 += Math.abs(array0[i].length - avg);	}	for (var j = 0; j < array1.length; j++) {		len1 += array1[j].length;		avg = len1 / (j + 1)		num1 += Math.abs(array1[j].length - avg);	}	if (len0 > len1) {		rtn0++;	} else {		rtn0--;	}	if (len0 / array0.length > len1 / array1.length) {		rtn0++;	} else {		rtn0--;	}	if (num1 > num0) {		rtn0++;	} else {		rtn0--;	}	return (rtn0 < 0) ? array1 : array0;}function txt2array(txt, comma, quote, line, trim) {	var array = new Array();	var tmp, rows=cols=0;	if (!txt) txt = "";	if (!comma) comma = ",";	if (!quote) quote = "\"";	if (!line) line = "\n";		txt2arrayError = false;		var check = (quote.length > 0);		var fields = (comma.length > 0) ? txt.split(comma): new Array(txt);		for (var i = 0; i < fields.length; i++) {		if (cols == 0) array[rows] = new Array();		if (check && fields[i].startsWith(quote)) {			var idx = quote.length;			while (idx > -1 && fields[i].indexOf(quote, idx) > 0) {				idx = fields[i].indexOf(quote, idx) + quote.length;				if (fields[i].substr(idx, quote.length) == quote) {					idx += quote.length;				} else if (fields[i].substr(idx, line.length) == line) {					array[rows][cols] = fields[i].substring(quote.length, idx - quote.length).split(quote + quote).join(quote);					cols = 0;					rows++;					fields[i] = fields[i].substr(idx + line.length);					if (fields[i].length > 0) i--;					idx = -1;				} else {					array[rows][cols] = fields[i].substring(quote.length, fields[i].length - quote.length).split(quote + quote).join(quote);					cols++;					idx = -1;					// Error?				}			}			if (idx > 0) {				if (fields.length - 1 > i) fields[i+1] = fields[i] + comma + fields[i+1];			}		} else {			if (check) {				if (fields[i].search((new RegExp("[^" + quote + "]+" + quote + "(" + quote + quote + ")*[^" + quote + "]+","g"))) > -1) {					txt2arrayError = true;					}			}			if (fields[i].contains(line)) {				array[rows][cols] = fields[i].mid(0, line);				cols = 0;				rows++;				fields[i] = fields[i].mid(line, fields[i].length);				//if (fields[i].length > 0) // comment out because it will remove the first empty item value 				if (i + 1 <= fields.length) 	i--;			} else {				array[rows][cols] = fields[i];				cols++;			}		}	}			if (trim) {		for (rows = 0; rows < array.length; rows++) {			for (cols = 0; cols < array[rows].length; cols++) {				array[rows][cols] = (array[rows][cols] + "").trim();			}		}	}	return array;}/*Returns the string without the heading/tailing spaces.Usage: stringvar.trim()Parameters:stringvar Must. The string to trim spaces.Returns:Returns the string without the heading/tailing spaces.*/String.prototype.trim = function() {	return this.replace(/^\s+/, '').replace(/\s+$/, '');};/*Returns the string without the heading spaces.Usage: stringvar.trimLeft()Parameters:stringvar Must. The string to trim spaces.Returns:Returns the string without the heading spaces.*/String.prototype.trimLeft = function() { 	return this.replace(/^\s+/, ''); };/*Returns the string without the tailing spaces.Usage: stringvar.trimRight()Parameters:stringvar Must. The string to trim spaces.Returns:Returns the string without the tailing spaces.*/String.prototype.trimRight = function() { 	return this.replace(/\s+$/, ''); };/*Returns the string with a substring padded on the left, right.Usage: stringvar.pad(length [, pad [, right]])Parameters:stringvar Must. The string to concat.length Must. The concatenated string's length. Not concat if the orginal string's length > specified length.padOptional. substring that will be concatenated. Use default string "0" if "" or not specified. It may be cut off if pad are more than one chars.rightOptional. Specifies the side where the concatenation will happen. false[Default]: left side; true: right side. Returns:The string with a substring padded on the left, right.Samples: var date = new Array("2011", "5", "18", "2", "20", "1"); msg += date[0] + "/" + date[1].pad(2) + "/" + date[2].pad(2) + " " + date[3].pad(2) + ":" + date[4].pad(2) + ":" + date[5].pad(2);*/String.prototype.pad = function(len, pad, right){	if (this.length >= len) {		return this;	}	len -= this.length;		// ten zeros	var pads = "0000000000";	if (arguments.length > 1 && pad.length > 0) {		pads = "" + pad;	}	while (pads.length < len) {		pads += pads;	}	return (right)? this + pads.substr(0, len) : pads.substr(0, len) + this;};/*Tests if the substring of this string beginning starts with the specified prefix, ignoring case differences. Usage: stringvar.startsWith(prefix [, ignoreCase ])Parameters:stringvar Must. The string to test.prefix Must. The string's prefix.ignoreCaseOptional. ignoring case differences when compareReturns:true if the character sequence represented by the argument is a prefix of the substring of this object starting at index toffset; false otherwiseSamples:  if("MM/DD/YYYY".startsWith("MM")) {    // ...  }  if("MM/DD/YYYY".startsWith("mm", true)) {    // ...  }*/String.prototype.startsWith = function(s, c) {	if (s && this.length >= s.length) {		var t = this.substr(0, s.length);		if (c) {			return (t.toLowerCase() == s.toLowerCase());		} 		return (t == s);	}	return false;};/*Tests if this string ends with the specified suffix, ignoring case differences. Usage: stringvar.endsWith(suffix [, ignoreCase])Parameters:stringvar Must. The string to test.suffix Must. The string's suffix.ignoreCaseOptional. ignoring case differences when compareReturns:true if the character sequence represented by the argument is a suffix of the character sequence represented by this object; false otherwise. Samples:  if("MM/DD/YYYY".endsWith("YYYY")) {    // ...  }  if("MM/DD/YYYY".endsWith("yyyy", true)) {    // ...  }*/String.prototype.endsWith = function(s, c) {	if (s && this.length >= s.length) {		var t = this.substr(this.length - s.length);		if (c) {			return (t.toLowerCase() == s.toLowerCase());		}		return (t == s);	}	return false;};/*Tests if and only if this string contains the specified sequence of char values ignoring case differences. Usage: stringvar.contains(sequence [, ignoreCase])Parameters:stringvar Must. The string to test.sequence Must. the sequence to search for ignoreCaseOptional. ignoring case differences when compareReturns:Returns true if and only if this string contains the specified sequence of char values. Samples:  if("MM/DD/YYYY".contains("YYYY")) {    // ...  }  if("MM/DD/YYYY".contains("yyyy", true)) {    // ...  }    String.prototype.pad = function(l, s, t){    return s || (s = " "), (l -= this.length) > 0 ? (s = new Array(Math.ceil(l / s.length)        + 1).join(s)).substr(0, t = !t ? l : t == 1 ? 0 : Math.ceil(l / 2))        + this + s.substr(0, l - t) : this;};*/String.prototype.contains = function(s, c) {	if (s && this.length >= s.length) {		if (c) {			return (this.toLowerCase().indexOf(s.toLowerCase()) > -1);		}		return (this.indexOf(s) > -1);	}	return false;}/*Tests if this string ends with the specified suffix, ignoring case differences. Usage: strVariable.mid(start[, end])Parameters:start Must. If Number type, the beginning index (0, if start<0); If String type, the string to beginning index, 0 if not fount.end Not Must. If Number type, the endding index; If String type, the string to endding index from start index, string end if not fount.Returns:the specified substring; "", if not found start/end string or end index < start index or start index < 0. Samples:  if("MM/DD/YYYY".mid("/", "/") == "DD") {    // ...  }  if("MM/DD/YYYY".mid(3, "/") == "DD") {    // ...  }  if("MM/DD/YYYY".mid(3, 5) == "DD") {    // ...  }*/String.prototype.mid = function(s, e) {	var L,R;	//typeof value："number", "string", "boolean", "object", "function", "undefined"	L = (typeof(s) + "").charAt(0);	if (L != 'n' && L != 's') return "";	R = (typeof(e) + "").charAt(0);	if (R != 'n' && R != 's' && R != 'u') return "";			if (L == 'n') {		L = (s < 0) ? 0 : s;	} else {		L=this.indexOf(s);		if (L < 0) {			L = 0;		} else {			L += s.length;		}	}	if (R == 'u') {		return this.substr(L);	}	R = (R == 'n') ? e : this.indexOf(e, L);	if (R < 0) {		R=this.length;	}	if (R <= L) return "";	if (R > this.length) R=this.length;		return (R < this.length) ? this.substring(L, R) : this.substr(L);}/*Replaces the lowest numbered place marker(%1, %2, ..., %9) with specified strings.Usage: strVariable.arg(arg0, [arg1...[, argN]])Parameters:arg0,...,argN Must. the string list to replace the marker.Returns:A copy of this string with the lowest numbered place marker replaced by string a, i.e., %1, %2, ..., %99.Samples:  var date = "%1/%2/%3".arg("05").arg(18).arg(2011); // date will be "05/18/2011"  date = "%1/%2/%3".arg("05", 18, 2011); // date will be "05/18/2011"    var now= new Array("05", 18, 2011);  date = "%1/%2/%3".arg(now); // date will be "05/18/2011"  date = "%1/%2/%3".arg("05", 18, "2011 %1:%2:%3").arg(12, 59, 59); // date will be "05/18/2011 12:59:59"  date = "%3/%2/%1".arg(18).arg("05").arg("2011"); // date will be "2011/05/18"  date = "%3/%2/%1".arg(18, "05", "2011"); // date will be "2011/05/18"  date = "%1/%2/%1".arg(18).arg("05").arg("2011"); // date will be "18/2011/05"  date = "%1/%2/%1".arg(18, "05", "2011"); // date will be "18/05/%1"  date = "%3/%2/%1".arg("18%1", "05%1", "2011%1"); // date will be "2011%1/05%1/18%1"  date = "%3/%2/%1".arg("18%1").arg("05%1").arg("2011%1"); // date will be "%3/%2/18052011%1"  */String.prototype.arg = function() {	if (arguments.length < 1 || !this.contains("%")) return this;		var args;	if (arguments.length == 1 && arguments[0] instanceof Array) {		args = arguments[0];	} else {		args = arguments;	}	var s = this;	var k = 0;	for (var i = 1; i < 10; i++) {		if (s.contains("%" + i)) {			s = s.replace("%" + i, args[k]);			if ((++k) == args.length) {				break;			}		}	}	return s; };String.prototype.toJSON = function() {	try {		if (!this.startsWith("{")) {			return eval("({"+ this +"})"); 		} else {			return eval("("+ this +")"); 		}	} catch (msg) {		return {"error": msg, "org": this};	}}/*String.prototype.fromJSON = function(obj) {	jsontxt = "";	try {	tojsonstr(obj);	} catch(e) {}	return jsontxt;}var jsontxt = "";function tojsonstr(obj) {	jsontxt += '{';  	for ( var i in obj) {		if (i == "__proto__") continue;			switch(typeof(obj[i])){   		case 'number':		case 'boolean':			jsontxt += '"' + i + '": ' + obj[i] + ',\n';			break;		case 'string':   			jsontxt += '"' + i + '": "' + obj[i].replace(/"/g, '\\"') + '",\n';			break;   		case 'array':			jsontxt += '"' + i + '": ';			toarraystr(obj[i]);			break; 		case 'object':   			if (obj[k] instanceof Array) {   				toarraystr(obj[k]);			} else if (obj==null) {   				jsontxt += '"' + i + '": null, ';			} else {				jsontxt += '"' + i + '": ';				tojsonstr(obj[i]);				jsontxt += ',\n';			}			break;		default:   			break;   	}   	}	jsontxt += '}';  }function toarraystr(obj) {	jsontxt += '[';	for (var k = 0; k < obj.length; k++) {		switch(typeof(obj[k])) { 		case 'number':		case 'boolean':			jsontxt += obj[k] + ', ';			break;		case 'string':   			jsontxt += '"' + obj[k].replace(/"/g, '\\"') + '", ';			break;		case 'array':   			toarraystr(obj[k]);		case 'object':   			if (obj[k] instanceof Array) {   				toarraystr(obj[k]);			} else if (obj==null) {   				jsontxt += 'null, ';			} else {				tojsonstr(obj[k]);				jsontxt += ',\n';			}			break;		}	}	jsontxt += '],\n';}*/String.prototype.formatSize = function(size) {	var len = size;	var u = " B";	if (len >= 1099511627776) { /* 1024*1024*1024*1024 */ 		len = (len / 1099511627776);		u = " TB";	} else if (len >= 1073741824) { /* 1024*1024*1024 */ 		len = (len / 1073741824);		u = " GB";	} else if (len >= 1048576) { /* 1024*1024 */ 		len = (len / 1048576);		u = " MB";	} else if (len >= 1024) {		len = (len / 1024);		u = " KB";	} else {		//	}	len += "";	if (len.indexOf(".") > 0) {		len = len.substr(0, len.indexOf(".") + 2);	}	return len + u;};	/*String.prototype.encodeAttr = function() {	if (this.contains("&amp;")) {		return this;	}	if (!this.contains("&amp;")) { 		this = this.replace(/&/g, "&amp;");	}	this = this.replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/\r/g, "&#10;").replace(/\n/g, "&#13;").replace(/\</g, "&lt;").replace(/\>/g, "&gt;").replace(/\\/g, "&#92;");	return this;}String.prototype.decodeAttr = function() {	if (!this.contains("&")) {		return this;	}	this = this.replace(/&#34;/, '"').replace(/&#39;/, "'").replace(/&#10;/, '\r').replace(/&#13;/, "\n").replace(/&lt;/, "<").replace(/&gt;/, ">").replace(/&#92;/, "\\").replace(/&amp;/, "&");	// .replace(/&#44;/, ",").replace(/&#47;/, "/")	return this;}	*/var _keyStr = "0123456789ABCDEFGHIJKLMNPQRSTUVW";/*Usage: strVariable.toN32([radix])*/String.prototype.toN32 = function(radix) {	var r = ((radix + "") in ["2", "8", "10", "16", "32"]) ? radix : 10;	var val = "";	var n = parseInt(this, r).toString(2);	var s = 0;	for (var e = n.length % 5; e <= n.length; e += 5) {		if (e > s) {			var i = parseInt(n.mid(s, e), 2);			val += _keyStr[i];		}		s = e;	}	return val;	}/*Usage: strVariable.fromN32([radix])*/String.prototype.fromN32 = function(radix) {	var r = ((radix + "") in ["2", "8", "10", "16", "32"]) ? radix : 10;	var val = "";	for (var i = 0; i < this.length; i++) {		val += _keyStr.indexOf(this.charAt(i)).toString(2).pad(5);	}	val = parseInt(val, r);	return val;	}String.prototype.toHex = function() {	return (new Number(this)).toString(16).toUpperCase();}/*false : 0;true : 非0;rguments 对象在函数代码中，使用特殊对象 arguments，开发者无需明确指出参数名，就能访问它们。例如，在函数 sayHi() 中，第一个参数是 message。用 arguments[0] 也可以访问这个值，检测参数个数还可以用 arguments 对象检测函数的参数个数，引用属性 arguments.length 即可。例如，如果存在两个类 ClassX 和 ClassY，ClassZ 想继承这两个类，可以使用下面的代码：function ClassZ() {    this.newMethod = ClassX;    this.newMethod();    delete this.newMethod;    this.newMethod = ClassY;    this.newMethod();    delete this.newMethod;}混合方式这种继承方式使用构造函数定义类，并非使用任何原型。对象冒充的主要问题是必须使用构造函数方式，这不是最好的选择。不过如果使用原型链，就无法使用带参数的构造函数了。开发者如何选择呢？答案很简单，两者都用。在前一章，我们曾经讲解过创建类的最好方式是用构造函数定义属性，用原型定义方法。这种方式同样适用于继承机制，用对象冒充继承构造函数的属性，用原型链继承 prototype 对象的方法。用这两种方式重写前面的例子，代码如下：function ClassA(sColor) {    this.color = sColor;}ClassA.prototype.sayColor = function () {    alert(this.color);};function ClassB(sColor, sName) {    ClassA.call(this, sColor);    this.name = sName;}ClassB.prototype = new ClassA();ClassB.prototype.sayName = function () {    alert(this.name);};由于这种混合方式使用了原型链，所以 instanceof 运算符仍能正确运行。*/	/*	var str = this.replace(/^\s+/, "");	var end = str.length - 1;	var ws = /\s/;	while (ws.test(str.charAt(end))) {		end--;	}	return str.slice(0, end+1);	*//*req.body: ObjectF0: ""F1: "dfa"F2: "someone@hp.com"F3: "30"F4: "user"F5: Array[3]0: "T11"1: "T10"2: "T01"length: 3__proto__: Array[0]F6: "afds"F7: "fasdf"F8: "T10"F9: "T11"F10: "2014/05/23"F11: "17:27:15"F12: "2014/05/23 17:27:15"__proto__: Object*//*F0:F1:fdaF7:asdfF2:someone@hp.comF3:30F4:userF5:T11F5:T10F5:T01F6:sfdaF8:T11F8:T10F8:T01F9:nullF10:2014/05/23F11:16:10:39F12:2014/05/23 16:10:39*/function getUData(req) {	var data = {};	if (req.method == "POST") {		data = req.body || {};	} 	if (req.url.contains("?")) {		var params = req.url.mid("?").replace(/\+/gi, " ").split("&");		for (var i = 0; i < params.length; i++) {			var k = decodeURIComponent (params[i].mid(0, "="));			var v = decodeURIComponent (params[i].mid("="));			if (k in data) {				if (data[k].constructor == Array) {					data[k].push(v);				} else {					var item = new Array();					item.push(data[k]);					item.push(v);					data[k] = item;				}			} else {				data[k] = v;			}		}	}	return data;}function run(source) {	try { return (source); } catch(msg) { return "ERROR: " + msg + "\n org: " + source; }}module.exports = {	getReqData: getUData,	text2array: text2array,	run: run,};